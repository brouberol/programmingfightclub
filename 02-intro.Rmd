# Introduction

You worked really hard for over a year in the next one billion dollar project in a small startup: the CEO, Johan, seems happy that the product is (almost) feature complete (it's never feature complete), the designer, Anders, is happy with the UX and graphics and the CTO, Pontus, just wants to press the red button and release the product. You tell them to wait 10 more minutes, the unit tests, integration tests and Xxxx tests are still running (adding tests was a long battle with everyone because it slowed down the project quite a lot, but you are a good engineer and tests will catch many errors now and in the future). 

- Ding, ding, ding (sound)

You look at the screen, all 142 tests are green! You tell Pontus to push the red button; deployment scripts start, your software is being installed on all the AWS servers the company could afford, a few database servers with replication for faster reads and a single leader for the writes, load balancer, reverse proxy servers for serving static data and another bunch of servers running your application. After a few minutes, the deployment is a success, your baby is ALIVE and by tomorrow morning your product will be featured in all the Swedish newspapers (you live in Stockholm of course, the European capital for startups).

The next day comes, you try the service as if you were a customer and observe that the system is just f****** slow, at times it seems that connections time out and you observe in your monitoring tools that the server is not processing that many requests. What the hell is going on!?

The CTO has the intuition that it could be related to that lock that was introduced for the concurrent access to the database and it may be as simple as releasing it. If that's the case, you'll fix the test that should have covered that and be presto in 5 min. There is one problem though, the code doesn't have a well defined structure and the lock somehow was passed inside a lambda -- you had to try out lambdas in Java, they are cool -- so you have no access to release it directly. More over, you are passing a bunch of closures and there's no easy way to tell which one has the damn lock! What do you do? You decide to create a new function that this time does what you want and somehow you'll fix the issue later. Phew, everyone knew you could solve it! 

Congratulations, you are the owner of a big plate of spaghetti code that no one can follow and, as a side effect, you cannot be fired.

**How did you end up in this situation?** I have the answer for you: you coded a system considering all the functional requirements and the architecture without any solid foundation --you forgot the problem to solve, the non-functional requirements -- because it was more important to try out all the new fancy features of the language. 

Many books explain software design with focus on one language (and paradigm) and assume that this
knowledge can be "easily" extrapolated to other languages and/or paradigms.
While it is true that you have to start from some point, it is also true that
as soon as you put it to practice in another language
their explanations may not be easy follow now or may
not even make sense from the language perspective (see Fig. \@ref(fig:taming-code)
for an example of the author's feelings when reading such books).

```{r taming-code, echo=FALSE, results='asis', fig.cap='Developer taming code'}
knitr::include_graphics("img/Table-Languages.png")
```

Our approach in this book is much more practical and can be extrapolated to other languages.
Yes, we am not contradicting the previous paragrah, you heard correctly!
We are going to cover software design from the perspective of different languages
(paradigms and type systems), and we are going to show different approaches to
solving the same problem. You will learn to take advantage of each of the
language constructs and benefit from it.

Before we start, let's do a recap on what **software design** means.

<!-- ```{block2, type='note'} -->
<!-- For more information on custom blocks, remember to visit: -->
<!-- https://bookdown.org/yihui/bookdown/custom-blocks.html -->
<!-- ``` -->


## Software Design
<!-- Definition -->
Software design is the process of finding a *satisfactory* solution to a problem.
Before one can start with an implementation there needs to be a clear specification of the problem to solve,
a good understanding of the domain of the system under design (you can draw a domain model to clarify ideas),
an (in)formal document that describes the steps necessary to solve the problem
(the Unified Modelling Language can help here with class and sequence diagrams, among others)
and a well-defined architecture.

<!-- Relation to agile methodogies -->
Given the definition above, designing software seems to be completely disjoint from
agile methodologies (e.g. Scrum) where you break user stories into smaller tasks
until everything is clear to the whole team. In Scrum there seems to be
no domain model, not a single static and/or behavioural diagram, no architecture, etc,
just *code what the post-it says*.
However, the post-it tells you **what the problem is** but not **how to solve it!**.
The domain modelling, static and behaviour models and architectural diagrams
are all tools under your belt that may be used if required, even in agile
methodologies.

<!-- Design is all about making decisions -->
Software design is all about making decisions.
Every problem involves taking small and big decisions and these influence the final
outcome of your software. For instance, the "simple" task of choosing a programming language
has a tremendous impact on your software. Choose a
dynamic language and you'll find quite a lot of errors at runtime (even if you use
a test-driven development approach). Other example is choosing between a
object-oriented or a functional language. No matter which one you choose, you can always write the same
piece of software using one paradigm or the other. However, one of them will
bring inherent benefits that have to be otherwise coded in the other approach.

```{r code-quality, echo=FALSE, results='asis', fig.cap='Code quality (http://xkcd.com/1695/)'}
knitr::include_graphics("img/XKCD-code_quality_2.png")
```


### What is a good design?

<!-- good design == flexible design -->
In general, **a good design is one that can deal with change**.
<!-- software design is all about change -> comparison with other engineers -->
A software engineer has to think much more abstract than other engineers, e.g. civil engineer.
For instance, as a civil engineer, you may have to think about building a bridge that can stand
`X` number of tons and, under any circunstance, not fall down.
As a software engineer, you have to think about a piece of code that today is a car, tomorrow is a submarine
and the next day is a tank and this happens because it is just code, anyone can
update it and it is not set in stone, ever.

<!-- intro to design patterns -->
There are many ways to solve a problem and, more often than not, there are common solutions.
Because of this, many problems has been studied for many years and they have a well documented solution.
These well-documented solutions are called **design patterns** and they exist for
all kinds of paradigms. In this book, we will focus on object-oriented and
functional design patterns.

### Design patterns

<!-- definition, adv and disv -->
A design pattern is a well-desgined solution to a common problem.
Design patterns are expressed in a concise and clear format, and they
follow a structure similar to the one below:

- *pattern name*, so that experts can refer to a common pattern
- *concise and well-defined problem specification*
- *unequivocal solution*
- *trade-offs of the pattern*

In this book, we follow this structure together with auxiliary UML class
diagrams (explained in later chapters).

<!--
Should I cover design patterns from ASD? YES

Should I cover UML? ... maybe not!

Introduction to other languages!

Design patterns:
- SOLID vs GRASP
- Design patterns for OOP and/or FP
- Testing to check that it works!
-->