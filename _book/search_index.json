[
["prologue.html", "Design Patterns for the Object-oriented and Functional mind 1 Prologue 1.1 Who is this book for? 1.2 What is covered in this book? 1.3 Organisation 1.4 Software requirements", " Design Patterns for the Object-oriented and Functional mind Kiko Fernandez-Reyes 2017-07-28 1 Prologue This book was originally written for the course Advanced Software Design, imparted at Uppsala University by Kiko Fernandez-Reyes, and provides a practical hands-on experience on software design. It extends the content of the course with a direct application of design patterns and software principles in the object-oriented paradigm, exploiting the type system. 1.1 Who is this book for? This book is directed to students of any computer science major, young developers, engineers or programmers who have already grasped the idea behind object-oriented programming. The reader should already be familiar with the following concepts from object-oriented programming: Classes, objects, inheritance, interfaces, abstract classes, parametric classes mixins and traits lambdas and closures Lambdas and closures belong to functional programming but they have become ubiquitous in the object-oriented paradigm too. For those in need of a quick reminder, I have included a recap chapter that summarises these concepts. If you are not familiar with object-oriented programming, you should first understand the ideas behind this paradigms and come back later to this book. 1.2 What is covered in this book? This book covers most of the design principles and design patterns used today in industry, necessary for building maintainable and flexible applications. All the principles and design patterns are written in two languages: Java and Python. These languages are already used in production in big companies and are well established. For instance, Pinterest uses Python for their backend operations and Java is widely used everywhere. The mix of these two languages covers two different type systems: static and dynamic. Why multiple languages? Each language has its strengths and weaknesses. In this book, I show how to apply the same design pattern by fully exploiting the main strengths of each language. In a typed language, you use polymorphism to guarantee that the object that you interact with satisfies its expected behaviour, while in an untyped system you exchange freedom from the safety (and sometimes rigidity) of a type system. Choosing a language is already an important design decision as languages are tied to a paradigm and a type system, and these cannot be changed. For this reason, it’s important to evaluate the language features and what the type system buys for us. For example: - Is it a pain to use the command pattern in Java using lambda notation? - Is Python (and its untyped nature) the best way to go to write large code bases that are resilient to change? In this book, we do not provide an absolute truth nor do we try to do so; we show that static and dynamic type systems have inherent benefits and drawbacks. You have to work through the examples and exercises to find your own truth and comfort zone. 1.3 Organisation The book is organised in 4 parts. The first part (chapters 1 and 2) puts in perspective what is software design, why design patterns are important and described the case study that we are going to build and refer to throughout the book. The second part introduces software principles to create flexible and maintainable software, known as GRASP and SOLID principles. Part 3 explains, in depth, core design patterns that are grouped into 3 categories: creational, structural and behavioural patterns. The last part builds a Web application using most of the patterns presented in this book. For each design pattern, there is a clear and concise explanation of the design pattern (sometimes illustrating a simple simile from the real world), its benefits and drawbacks. Afterwards, the pattern is explained, we include easy to grasp examples to get you familiar with the language and the design pattern. As mentioned above, for a full example that combines software principles and patterns, you should refer to the last chapter. 1.4 Software requirements This book contains code written in Java and Python. This section contains the exact versions of the languages used in this book. 1.4.1 Java 8 All examples written in this book has been tested using the Oracle JDK 8u111. Instructions on how to install Java can be found in http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html. 1.4.2 Python 3.6 All examples written in this book has been tested for Python 3.6.0. Instructions on how to install Python 3.6 can be found in https://www.python.org/downloads/. Introduction - Fight Club "],
["introduction.html", "2 Introduction 2.1 Software Design 2.2 Design patterns", " 2 Introduction You worked really hard for over a year in the next billion dollar web app in a small startup: the CEO, Johan, seems happy that the product is (almost) feature complete, the designer, Anders, is happy with the UX and graphics and the CTO, Pontus, just wants to press the red button and release the product. You tell them to wait 10 more minutes, the unit tests, integration tests and system tests are still running (adding tests was a long battle with everyone because it slowed down the project quite a lot, but you are a good engineer and tests will catch many errors now and in the future). Ding, ding, ding (sound) You look at the screen, all 142 tests are green! You tell Pontus to push the red button; deployment scripts start, your software is being installed on all the AWS servers the company could afford, a few database servers with replication for faster reads and a single leader for the writes, load balancers, reverse proxy servers for serving static data and another bunch of servers running your application. After a few minutes, the deployment is a success, your baby is ALIVE and by tomorrow morning your product will be featured in all the Swedish newspapers (you live in Stockholm, the European capital for startups). The next day comes, you try the webapp and observe that the system is just f****** slow. It seems that connections time out and you observe in your monitoring tools that the server is not processing that many requests. What the hell is going on!? The CTO has the intuition that it could be related to that lock that was introduced for the concurrent writes to the database and it may be as simple as releasing the lock. If his intuition is right, you’ll fix the code, add the test that should have covered that case and be presto in 5 min to re-deploy the application. There is one problem though, the code doesn’t have a well defined structure and the lock somehow was passed inside a lambda – you had to try out lambdas in Java, they are cool – so you have no way to releasing the lock directly. More over, you are passing a bunch of lambdas and there’s no easy way to tell which one has the damn lock! Shit, if only you knew when made sense to use lambdas and all the cool features of the language! . How did you end up in this situation? You coded a system considering all the functional requirements and the architecture but you failed to create a good design. The hype of new features seemed like a silver bullet and everyone is using them (same thing happens with new frameworks all the time). The problem is understanding when to use those shiny new features and how they affect your design. 2.1 Software Design Many books explain software design with focus on one language and assume that this knowledge can be “easily” extrapolated to other languages and/or paradigms. While it is true that you have to start from somewhere, it is also true that as soon as try to put design patterns into practice in another language their explanations may not be easy to follow or may not even make sense, from the language’s perspective. (image from https://xkcd.com/1513/) Our approach in this book is much more practical and can only be extrapolated to other languages once there is a common understanding of how the type system interplays with the most common software design patterns. For this reason, we are going to cover design patterns from the perspective of different languages and type systems, and we are going to show different approaches to solving the same problem. You will learn to take advantage of each of the language constructs, when to use them and when avoid them. Before we start, let’s do a recap on what software design means: Software design is the process of finding a satisfactory solution to a problem. Before one can start with an implementation there needs to be a clear specification of the problem to solve and a good understanding of the domain of the system under design (you can draw a domain model to clarify ideas). You can also write an informal document that describes the steps necessary to solve the problem (class and sequence diagrams can help here) and notes about the expected non-functional requirements, i.e., importing your friends’ favourite places cannot block the main thread and should finish in less than 30 seconds. 2.1.1 Agile methodologies Given the definition above, designing software seems to be completely disjoint from agile methodologies, e.g. Scrum, where you break user stories into smaller tasks until everything is clear to the whole team. In Scrum there seems to be no domain model, not a single static and/or behavioural diagram, no architecture, etc, just code-what-the-post-it says. There is one problem if this approach is taken literally though: the post-it tells you what the problem is but not how to design it! You, as a software engineer, should look at domain modelling, static and behaviour models and architectural diagrams as tools under your belt that may be used if required, even in agile methodologies. Software design is all about making decisions. Every problem involves taking small and big decisions and these influence the final outcome of your software. For instance, the “simple” task of choosing a programming language has a tremendous impact on your software. Choose a dynamic language and you’ll find quite a lot of errors at runtime (even if you use a test-driven development approach). Other example is choosing between a object-oriented or a functional language. You can always write the same piece of software using one paradigm or the other. However, one of them will bring inherent benefits while the other one puts some extra burden in your code. (Image from http://xkcd.com/1695/) 2.1.2 What is a good design? In general, a good design is one that can deal with change. A software engineer has to think much more abstract than other engineers, e.g. civil engineer. For instance, as a civil engineer, you may have to think about building a bridge that can stand X number of tons and, under any circumstance fall down. As a software engineer, you have to think about a piece of code that today is a car, tomorrow is a submarine and the next day is a tank and this happens because it is just code, anyone can update it and it is not set in stone, ever. There are many ways to solve a problem and, more often than not, there exist well-study common solutions. These well-documented solutions are called design patterns and they exist for all kinds of paradigms. In this book, we will focus on object-oriented design patterns. 2.2 Design patterns A design pattern is a well-designed solution to a common problem. Design patterns are expressed in a concise and clear format, and they follow a structure similar to the one below: pattern name, so that experts can refer to a common pattern concise and well-defined problem specification unequivocal solution trade-offs of the pattern In this book, we follow this structure together with auxiliary UML class diagrams (explained in later chapters). "],
["recap.html", "3 Recap 3.1 Type systems 3.2 Object-oriented concepts 3.3 Functional concepts 3.4 Case Study", " 3 Recap This section covers basic concepts from type theory and the object-oriented paradigm. Today’s object-oriented paradigm borrows two concepts from functional programming: lambdas and closures. During this recap, we will go through the core ideas of object-oriented programming using Java and Python 1 By the end of this chapter, you should understand: difference between Java’s and Python’s type systems, classes and objects, inheritance, interfaces, traits and mixins, abstract classes, parametric classes and lambdas and closures 3.1 Type systems Talk about the main difference between Java and Python duck typing weakly typed strongly typed 3.2 Object-oriented concepts We proceed to explain the core ideas of object-oriented programming using examples from the case study. 3.2.1 Classes Classes declare and implement the state and behaviour of an object. The state of a class lives in its attributes while the behaviour is expressed via its methods. A class that hides its attributes with a private access modifier (remember public, protected and private?) protects its internal state from other classes, so that the only way to update the internal state is via method calls. Method calls represent the behaviour of the object. As a general advice, you should not expose the internal state of your class to others; you should expose your behaviour. This is what make great abstractions easy to use and understand. For example, when using the future API, you do not have to think about the possible locks that may exist in the internal representation of a CompletableFuture, you just use it according to its defined behaviour, public methods. Classes expose their behaviour via their methods. If these methods just get the attributes and set them, we call them getters and setters. That’s enough for a short introduction. Let’s write the Restaurant class to remember how to write Java: Java The class Restaurant has all attributes defined as private (not accesible from outside the class). The constructor of the class (public Restaurant(...)) creates a new Restaurant and sets its state to some default value. To get the state outside the class we use getters and setters methods. These are preceded by the words get and set following the attributes name, e.g. getStars() (Example 3.1.1.1). public enum Stars { ONE_STAR, TWO_STAR, THREE_STAR, FOUR_STAR, FIVE_STAR, ZERO_STAR } public class Restaurant { // Michelin stars private Stars stars; private String street; private int zipcode; private Country country; // constructor public Restaurant(Stars stars, String street, int zipcode, Country country){ this.stars = stars; this.street = street; this.zipcode = zipcode; this.country = country; } // getter method public Stars getStars(){ return this.stars; } // setter method public void setStars(Stars stars){ this.stars = stars; } ... } Example 3.1.1.1. Introductory example to Java Python Python doesn’t have access modifiers and uses (by convention) an underscore to mean that the attribute is private. The constructor def __init__(self, alert=False) method takes explicitly an instance of itself self and a default argument, alert that, if it’s not provided, it is set to False. Before we continue disecting the constructor, let’s briefly introduce getters and setters. Python provides a special syntax for getters and setters that wrap the attribute into a function with that very same name. For instance, the getter for the alert attribute is created by declaring a method with the name of the attribute and the @property on top of it. The body of the method just fetches the attribute. @property def alert(self): return self.__alert Setters work in the same way, except that they are annotated with the attribute’s name followed by the setter word, e.g. @alert.setter for the alert setter method. From now on, when we call on self.alert we are actually calling the getter method and when we assign self.alert = True, we are calling the setter method. Now, if we go back to the __init__ method from Example 3.1.1.2, we can observe that this is indeed the desire behaviour. Why would we want to use getters and setters like that? Young padawan, they are an abstraction. Now you only want to retrieve the data but, with this abstraction, you could be returning cached data that otherwise needs to be fetched from the network. Later on, we will learn about the decorator pattern and how it rocks in Python! class Dog: def __init__(self, alert=False): self.alert = alert @property def alert(self): return self.__alert @alert.setter def alert(self, new_alert): self.__alert = new_alert def bark(self): if self.alert is True: println(&quot;Woof Woof&quot;) Example 3.1.1.2 Introductory example to Python 3.2.2 Objects Objects represent instances of the class at runtime. An object gets the default state defined by their constructor and the behaviour defined from the class declaration. Java Following the example before, let’s create an object: Dog dog = new Dog(); This calls on the constructor of the Dog class that sets the alert state to false. If the dog tries to bark nothing will happen: dog.bark(); The dog barks when it is startled, let’s make her bark: dog.setAlert(true); dog.bark(); // prints &quot;Woof Woof&quot; Python Creation of an object is similar to Java: dog = Dog() To make the dog bark: dog.bark() which does nothing because the dog is not startled. Let’s use the setter to change its state and make her bark: dog.alert = True dog.bark() # prints &quot;Woof Woof&quot; Notice that in this case, we could have set the initial state of the dog and would not have had to use a setter: dog = Dog(True) dog.bark() # prints &quot;Woof Woof&quot; 3.2.3 Inheritance A class can inherit methods from other classes, called inheritance. The class that inherits methods is called subclass while the class that provides them is called super class. Java has single inheritance, meaning that the subclass can inherit only from a single class while Python has a limited form of multiple inheritance. Idea: A computer has various levels of memory, L1, L2, Last-level cache and main memory. In this example, the class Computer inherits operations from memory, so that we can call methods that retrieve objects from main memory. (this is an example and I would not advice any one to create a virtual machine based on this idea) Java Since Java can only inherit from a single class, we can model the idea above as shown in Example 3.1.3 Java inheritance. class Memory { private CacheL1 l1; private CacheL2 l2; public Memory(){ int kilobyte = 1024*1024; int megabyte = 1024 * kilobyte; this.l1 = new CacheL1(512*kilobyte); this.l2 = new CacheL2(3*megabyte); } public Object fetchLocation(Location lo) { // ... } } class Computer extends Memory { public class Computer(){ // ... } } Example 3.1.3 Java inheritance The class Computer inherits the methods Memory when Computer extends Memory. This means that we can fetch objects from memory, computer.fetchLocation(location);. Python Python supports two forms of multiple inheritance, known as old-style and new style. In the old-style form, the multiple inheritance works in depth-first and left-to-right order. For instance: class L1(object): def send_info(): print &quot;Sending from L1 to bus&quot; class L2(object): def send_info(): print &quot;Sending from L2 to bus&quot; class Cache(L1, L2): pass class CPU(object): def send_info(): print &quot;Sending info from CPU to bus&quot; class Computer(CPU, Cache): pass c = Computer() c.send_info() Example 3.1.3 Python old-style In this case, the c.send_info() method prints Sending info from CPU to bus. If we were to change the order of the inherited classes, class Computer(Cache, CPU), then the printing method would have been Sending from L1 to bus. The multiple inheritance new style kicks in when classes do not inherit from object (as opposed to what L1 and L2 do in Example Python old-style). The new style considers breath-first and left-to-right order. class L1: def send_info(): print &quot;Sending from L1 to bus&quot; class L2: def send_info(): print &quot;Sending from L2 to bus&quot; class Cache(L1, L2): pass class CPU: def send_info(): print &quot;Sending info from CPU to bus&quot; class Computer(Cache, CPU): pass c = Computer() c.send_info() Example 3.1.3 Python new style In Example 3.1.3 Python new style, the c.send_info() method would have printed Sending info from CPU to bus given that Cache does not provide a suitable send_info method explictly. (More details in here: http://www.python-course.eu/python3_multiple_inheritance.php) 3.2.4 Interfaces TODO: missing default methods and static methods in interfaces (they can have implementations!) Interfaces declare a contract of the expected behaviour of classes that implement the interface. An interface merely defines methods. Classes that would like to be compatible with the interface need to implement those methods. The real purpose of interfaces is to enable polymorphism, e.g. being able to call methods on different classes because they implement the same interface. Java has interfaces but Python completely lacks them. Dynamic languages such as Python cannot express interfaces because they don’t have a static type system, the fact of not having static types inhibits interfaces. Java In Java an interface is declared similar to how classes are declared, except that you use the word interface. interface MemOperations { public Object fetchLocation(Location loc); public void flush(); public void sendToBus(); } public class CacheL1 implements MemOperations { public CacheL1(int size){ //... } public Object fetchLocation(Location loc){ // ... } // ... public void flush(){ System.out.println(&quot;Flushing from CacheL1&quot;); } } public class CacheL2 implements MemOperations { // ... public void flush(){ System.out.println(&quot;Flushing from CacheL2&quot;); } } Example 3.1.4 Java interfaces If you forget to implement one of the methods declared in the interface, the type system will throw an error and complain that you forgot to implement the missing methods. You won’t get unexpected crashes at runtime because the method doesn’t exist. From the Example 3.1.4 Java Interfaces we can create different cache levels and treat them as if they are just MemOperations. Calling methods on each one prints a different String. CacheL1 c1 = new CacheL1(512); CacheL2 c2 = new CacheL2(2048); ArrayList&lt;MemOperations&gt; a = new ArrayList&lt;MemOperations&gt;(); a.append(c1); a.append(c2); for(cache: a){ cache.flush(); } // prints: // &quot;Flushing from CacheL1&quot; // &quot;Flushing from CacheL2&quot; As of Java 8, interfaces can declare a default implementation for methods. This is great from the design point of view: you can provide a default implementation as long as you rely only on the known behaviour (other public methods of the interface). This means that you can create a clean design that does not rely on internal state and/or methods. TODO: Template pattern fits here perfectly! TODO: Should I explain polymorphism here? It’s GRASP… TODO: Should I show a code example? TODO: I believe I am explaining super basic stuff and should level up… 3.2.5 Abstract classes Abstract classes can be seen as a mix between interfaces and classes: they can contain attributes, define methods and declare abstract methods. Abstract methods provide a declaration of the behaviour but not a definition (implementation). An abstract class cannot work on its own – cannot be instantiated alone – and needs to be subclass by another class, which implements the abstract methods. Java It may seem as if Interfaces (as of Java 8) and Abstract Classes serve the same purpose. However, there is a subtle difference: an interface can only create public methods and constant declarations (static and final attributes) while an abstract class can declare and define the internal state of the class. As an advice, I would recommend to use interfaces whenever you have various subclasses that need to implement the same behaviour. I would consider the use of an abstract class in limited cases and only when there is a need to share the same private state among objects that are quite similar. TODO: Favour composition over inheritance abstract class Entity { private int life; private Equipment equipment; public Entity(int life, Equipment Equipment){ this.life = life; this.equipment = equipment; } public int getLife() { return this.life; } public void setLife(int life) { this.life = life; } abstract void attack(Enemy e); abstract void escape(); // ... } interface Attackable { public int getPower(); default void attack(Enemy e){ e.setLife(e.getLife() - getPower()); } } public class Hero { public void attack(Enemy e){ // Filter equipment by things that I can attack with Attackable attackable = this.equipment.attackable(); // attack attackable.attack(e); } } TODO: equipment may use the null pattern Python Test 2 3.2.6 Parametric classes 3.3 Functional concepts 3.3.1 Anonymous functions / lambdas 3.3.2 Immutability 3.3.3 High-order functions 3.3.4 Parametric functions 3.3.5 Algebraic data types 3.3.6 Multi-functions 3.4 Case Study (Image public domain https://commons.m.wikimedia.org/wiki/File:VWKombi@theBeach(byCarolineGutman).jpg) The following case study will be used throughout the book to teach you important design concepts and principles. The reader exercises are also based on this case study. Startup idea The startup you work for has this idea of building a travelling social network: a mix of Twitter, TripAdvisor and Pinterest all in one site. To build this idea, there will be a web server (backend) and a mobile app (front-end). The idea is the following: Based on your friends recommendations, you get your own personal guides with places to visit, restaurants, hotels, etc., all based on curated content from people you trust. These guides don’t show the typical and perfect pictures from the owner of the place, but the ones your friends have uploaded. If there are too many pictures from your friends, the system selects the best pictures using an AI algorithm and shows these in the cover of the guide. The comments are limited to 200 characters, making sure recommendations go directly to the point. Future work will allow any use to post also video comment of no more than 30 seconds. In the beginning, your friends may not yet be part of this platform. To get you started with the most relevant content from your friends, you can enable the integration with TripAdvisor and we will import your reviews, your friends’ and also photos from your friends and people you follow. Another important feature is to show the location of the places (in a guide) in a map and pinpoint exactly the distance to the place and average time by public transport and walking time. All of these features are meaningless unless you can use the app offline. Thus, the app should work in offline mode and sync with the server once there is internet connection. Your team works using an agile methodology, Scrum, and there are post-it everywhere with the list of functional features (we will go through the list of non-functional later on). [IMAGE] (Image taken by Logan Ingalls, source ) Coding the information One way to identify classes is to look at the domain model 3, since the concepts from the domain need to be coded in the application. Given the sales pitch above, you can easily identify the following concepts: - Lodge (Hotel, apartment, etc) - Point of interest (POI) - Restaurant - Bar - Nightclub - Person - Friend - Picture - Video - Comment - Review - Guide - etc (enough for now) The domain concepts represent important ideas of our domain. These will be coded into classes that represent the data layer of our application and contains business logic that is encapsulated within each of the classes. We proceed to explain object-oriented programming using examples this domain. We cannot cover the object-oriented core ideas in depth; the reader should understand this chapter as a quick reminder of concepts that are you are familiar with. Thus, if you are not familiar with the notions presented in this chapter, we would recommend the following reading material: * Reading material↩ Python allows creation of abstract classes via meta classes. These concept is a bit more advanced and may be covered upon receiving some initial feedback.↩ this refers to the concepts of the domain in discourse, that is, the entities and ideas that make up the travelling social network.↩ "],
["grasp-principles.html", "4 GRASP principles 4.1 Low Coupling 4.2 High Cohesion 4.3 Creator 4.4 Information Expert 4.5 Controller 4.6 Polymorphism 4.7 Indirection 4.8 Pure Fabrication 4.9 Protected Variation 4.10 Pure functions", " 4 GRASP principles Before you learn advanced design patterns, it’s useful to look at common principles / recommendation rules to guide your design. By following these principles, you will design and write code that’s easy to understand, maintain, and refactor. By the end of this chapter you will have grok these principles and they will become second nature to you. Next, we introduce these principles ( which can be applied to any object-oriented language): - low coupling, - high cohesion, - creator, - information expert, - controller, - polymorphism, - indirection, - pure fabrication, and - protected variation. There are exercises for each principle at the end of the chapter to help you understand the difference between them. 4.1 Low Coupling This principle states that a class should only depend on the minimum and required amount of classes, no more and no less. A low coupled class is easy to maintain and refactor because it interacts with a minimum amount of objects. A high coupled class has many dependencies to other objects and has low cohesion, i. e. it is not focused, has too many responsibilities and does too many things. A low coupled design is easy to change and the changes do not spread across multiple classes. In the beginning of your journey to become a better programmer, it’s difficult to acknowledge this principle until you deal with its counterpart, a high coupled bowl of spaghetti code. For this reason, it is much easier to spot a highly coupled design than to identify a low coupled one. We define coupling as any code that satisfies items in the following list: - the class has an attribute to another object, - calls on methods of other objects, - inherits from another class, - implements one or more interfaces, and - inherits mixins The reader should notice that there will always exist coupling but, dependencies to stable items are not problematic – standard library – because these have been well designed and do not change often. The problem is not coupling per se, but creating a highly coupled design to unstable objects. Example: (Example of high coupled design) Better alternative is the following code: (Example of low coupled code) Exercise based on case study 4.2 High Cohesion Cohesion refers to the property of staying focus on the responsibilities of the class. A cohesive class does one thing and does it well. Highly cohesive code is focused and, as side effect, doesn’t talk to too many objects. Often you’ll see code that contains many methods, attributes and seems to contain a lot of logic and magic. From now on, please know that this is the antipattern known as“The Blob”, result of a high coupling and low cohesion. (Image of the Blob) Example of The Blob antipattern: (Code, better if it’s from a real example) You can identify highly cohesive code if: - code doesn’t mix responsibilities, - has few methods, - doesn’t talk too many objects. Dependence relationship: Coupling and cohesion usually go hand in hand, since code with low cohesion is code that does too many things, hence it relies on too many objects. One way to look at it is to understand coupling as the relation between subsystem and cohesion as the relation within a subsystem. For instance, the following code shows these two weaknesses in Figure X. (Listing of high coupled and low cohesion code) (Figure X) These figure further shows how a change in one class affects many other classes thus, the code becomes more complex and difficult to maintain. If we refactor this code, it ends up as listing Yyy, Figure Yy6y. (Listing Yyy) (Figure Yy6y) Exercise: given the following code, add the following functionality: - feature a - feature b - feature c Reflection: - How many classes did you change? - does it seem like such a design is flexible and easy to refactor? Exercise: Refactor the baseline code from the above exercise to achieve low coupling and high cohesion. Add more features a, b, and c. Reflection: does it seem like this design is flexible and easy to refactor? 4.3 Creator This principle is likely overlooked but it plays a crucial role in object-oriented programming; the creator establishes who is responsible for creating an object. If you defined it well, your code will exhibit loose coupling and high cohesion; err an you will begin your journey to maintaining spaghetti code. Application: a class X is the creator of an object Y if any of the following statements are satisfied: - class X initialises object Y - class X contains object Y - class X closely uses and depends on class Y For instance, a point of interest (POI) has comments, hence POI is the creator of instances of the Comment class. Exercise: what kind of benefits and drawbacks do I get if POI is not the creator of comments? Solution: if comments are always the same, just text, then it makes sense that POIis the creator. However, what if I want to support multiple kinds of comments, i.e. video comments, text, or images as à comment? In that case, you are better off injecting the comments as an extra argument to the POI object. – does this makes sense? POI is always created first and comments are added later on, it’s not an initialiser but a method that adds comments. 4.4 Information Expert Classes have methods that define their responsibility and behaviour. A class exposes its behaviour via methods and its internals should always be opaque. With this basic idea, this principle helps you to identify the behaviour of each class. A class is responsible for a behaviour if that class contains all the information to carry it out. For example, which object should be responsible for updating the description of a guide? a. User object b. POI (point of interest) object c. LatitudeLongitude object d. Guide object This one is easy. Lets consider each option: a. If we update the guide description via this.user.setGuideDescription(newDescription) it implies that each user has a single guide, otherwise we would not know which guide we are updating. It could also mean that each user may be uniquely identified by its email and its guide. This is a really bad design from the relational point of view, database-wise. When representing the data layer from a NoSQL database this is allowed and I have seen it in use. I do not think this is a good model since, in the database, each record with the the same email is treated independently. b. A point of interest, such as a view, may be linked to multiple guides. For this reason, similar to above, such a design is non-maintainable. c. This really does not make sense. d. We have a winner! The guide instance has all the information to update the guide. The information expert assigns responsibilities to the classes that have all the information to fulfill the action. Exercise: A user wants to submit a few pictures with a review of her favourite restaurant in Málaga, Spain. Which of the following classes should be the information expert and provide that behaviour? a. User object b. Guide object c. Review object 4.5 Controller Controller 4.6 Polymorphism This principle is one of the most important ones in object-oriented programming and the one that makes OOP great at dividing responsibilities between classes. As we saw in the recap section, this polymorphism refers to classes that implement an interface or inherit from a top class and not to parametric classes, which is also polymorphic on the (opaque or bounded) type variable. This principle allows classes to specify the same responsibilities via an interface but decouples the behaviour for each type. For instance, in our application, we want to show a special logo on top of the pictures of famous users who have confirmed their identity. A valid design, that does not scale, has a single User class with an attribute named confirmedIdentity which sets the flag to true when the user has confirmed its identity. This design works for 2 users, the normal and confirmed users. Tomorrow, Johan (CEO) wants to add a new kind of user who represents a company instead of a person, companies cannot create accounts and they have confirmed its identity. Creating a company’s profile as a confirmed user seems wrong and error prone, it makes no sense the attribute confirmedIdentity for a company’s profile because we know that this will always be true. The current code looks like listing Xxxx. (Listing Xxxx) Another design choice is to represent this distinction of different users using an enum attribute. Based on this value, the displayImage() method adds logic to check which kind of user you are and how to display the image. You go home thinking that this is a good design, all the logic it’s kept in a single method. The problem with this approach, quite often used by beginners or as a shortcut, is that different classes are encoded within the same single one. This design is not maintainable in the long run because the same class encodes behaviour for different objects. Your design is abstracting at the wrong level. A better approach is to create a class for each kind of user and dispatch dynamically. This design is easier to maintain because the behaviour is not encoded solely on the method, but on the type. The Figure Yyy shows how to dynamically dispatch based on the type. Exercise Write the code depicted on Figure Yyy. Exercise Write the main class and show that the method performs a dynamic dispatch based on the classes. Exercise Write the code relying on inheritance and another version relying on interfaces. What are the benefits and drawbacks of the design and implementation decisions? (Note: this is distinct for Python because there’s no interface etc. Think how would you explain it in python) Python is a dynamic language with a weak type system. This means the language assigns types at runtime, but you as a developer won’t get any type error at compilation time. In Python polymorphism is always given and you as developer are in charge of ending that the methods you call exist or you will get a runtime error. As we said, the are no interfaces that we are bound to and python supports what’s called duck typing, which is an idea much closer to how things work in real life. Let me show this with an example: you can read articles, news, cereal boxes and anything that has text. In Java you are bound by the type of object you are but in Python you are bound to the behaviour you have. A method call on newspaper. hasText() and cerealBox.hasText() works in Python independent from their type; Java would make this work only when they belong to the sand type or interface. For this reason, Python is more expressive in this regard, although it sacrifices static typing guarantees and forces the developer to either handle exceptions or crash and burn at runtime if the object on which the program calls the method hasText() does not provide such behaviour. Exercise write the code depicted on Figure Yyy in Python. Do not forget to handle exceptional cases. Exercise Write the main class and show that the method performs a dynamic dispatch based on the classes. 4.7 Indirection Domain objects may end up being coupled to other objects in the first iteration of your design. This principle states that you should create an intermediate object that mediates between these two, hence reducing coupling. To the untrained eye, it may seem as if two objects that where coupled, after applying the principle, are still coupled but to other object. This reasoning is right, except that this indirection breaks the idea of once object having a direct relation to the other one. The layer in between breaks the coupling direction and creates a more flexible design, since the two initially coupled objects do not need to know anything about each other anymore. An example of this pattern (Figure zzz) is the indirection introduced between a guides and the images that belong to the guides. The idea here is that the same guide is shared among friends and each one of them may potentially see a different cover image. Prior to this principle, your initial solution was to duplicate the guide for each friend and recalculate the cover image for each of them. This solution is redundant, consumes memory, and duplicates data, so an update on one description involves updating all data in all copies of the guide. A better solution is to add a new level of indirection between a guide and its cover image, ’CoverManager`, that knows how to retrieve the best cover image for the calling object. Internally, the manager may have to call the AI algorithm from time to time to update the image, cache it if the same user keeps coming to the same guide and even persist this mapping of guide-cover image in the database if the cover image doesn’t change that often. (Figure zzz) Exercise Following the principles of these chapter, how would you design data persistence of an object from the case study? That is, would you add CRUD (Create, Read, Update and Delete) methods to all domain objects? If so, how would you avoid the coupling introduced by this design? Exercise How would you design the offline mode of your application? That is, how do you deal with low connectivity or no connectivity at all? Solution: you never assume that there is a connection and instead create an intermediate layer that handles the communication. If the server is unreachable, this layer handles how to proceed. An advanced design pattern that users this idea is the circuit breaker (explained in later chapters) 4.8 Pure Fabrication The term pure fabrication means to make something up. Use this principle whenever you observe that your domain classes are getting too overloaded, i.e., the start to exhibit high coupling and low cohesion. The principle adds a new indirection between two objects that would otherwise be directly connected (coupled). The indirection means adding a new object that mediates the communication between two other entities. This indirection object is not part of the domain and will be a made software concept. Examples of this principle are: object pools, database classes, and pretty much any object that sits in between two domain objects. In terms of design patterns, this principle is observe in the adapter pattern, shown in Figure xyz. (Figure xyz) Explain figure. Exercise:Wwhere could this principle be applied in the case study? Why? (There are many valid examples) Solution: the AI algorithm that inject images to guides. If this was not there, every guide would have the same image for all guides, tying the guide to the images. With the algorithm, the same guide share with friends shows different images based on other friends and connections. Exercise: let’s assume that you would like to add a notification system to the mobile app of the case study whenever a friend posts a new comment on one of her guides. What classes would you need to create? Solution: at the very least, you would need a Notification class that contains the text and image of the notification and some kind of notification manager that schedules and send notifications to the appropriate parties. 4.9 Protected Variation This principle is easy to apply and, in practice, requires you to be good at forecasting future pivot points or changes of direction. The core idea of this principle is to shield your code in places where you expect changes, let that be via interfaces or other means. For example, if we were to provide special guides that users can buy, we would need to integrate with a payment platform. If you are not sure which one is best, you’ll end up picking one and calling their methods where necessary. However, what happens if you see that platform Z has low commissions? You would want to change. ReFactoring may not be so easy because both payment solutions have different libraries with different API. So, you need to change all those specific calls by whatever the new API and workflow mandates. One way of solving this problem is via an interface and different classes that implement those methods (Figure XYZ). In this design, you are protecting yourself from future changes. Your concrete classes that implement the interface maintain the workflow and your only job is to create a new concrete class that implements your interface. You should apply this pattern to instability points and, specially, when using third party libraries that you don’t have previous experience with. 4.10 Pure functions This principle is not part of the common and well known GRASP principles but, in my experience, you should consider it. Lambdas, closures and pure functions are ubiquitous nowadays. My advice is that you stop using closures that captures mutable state. The main reason is that, at one point or another, you’ll benchmark your application and start using parallel capabilities of your computer: task, futures, actors or whatever is the next parallel abstraction. If you encapsulate mutable state in closures, you are building your own coffin for the not so far away future. Things like processing an recognitive computation cannot be used anymore if the object the closure captures is shared between two threads – unless you can guarantee data race freedom. Data race freedom code is hard to write, maintain and make fast, so using locks may get you out of troubles at the cost of losing horizontal scalability 4. explain↩ "],
["design-patters-creational.html", "5 Design Patters: Creational 5.1 Abstract Factory 5.2 Builder 5.3 Factory Method 5.4 Object Pool 5.5 Prototype 5.6 Singleton", " 5 Design Patters: Creational Covers creational design patterns TODO: Text is copied from https://sourcemaking.com/design_patterns, do not copy this! 5.1 Abstract Factory Creates an instance of several families of classes 5.2 Builder Separates object construction from its representation 5.3 Factory Method Creates an instance of several derived classes 5.4 Object Pool Avoid expensive acquisition and release of resources by recycling objects that are no longer in use 5.5 Prototype A fully initialized instance to be copied or cloned 5.6 Singleton A class of which only a single instance can exist "],
["design-patters-structural.html", "6 Design Patters: Structural 6.1 Adapter 6.2 Bridge 6.3 Composite 6.4 Decorator 6.5 Facade 6.6 Flyweight 6.7 Proxy", " 6 Design Patters: Structural Covers structural design patterns 6.1 Adapter 6.2 Bridge 6.3 Composite 6.4 Decorator 6.5 Facade 6.6 Flyweight 6.7 Proxy "],
["design-patters-behavioral.html", "7 Design Patters: Behavioral 7.1 Chain of responsibility 7.2 Command 7.3 Interpreter 7.4 Iterator 7.5 Mediator 7.6 Memento 7.7 Null object 7.8 Observer 7.9 State 7.10 Strategy 7.11 Template method 7.12 Visitor", " 7 Design Patters: Behavioral Covers behavioral design patterns 7.1 Chain of responsibility 7.2 Command 7.3 Interpreter 7.4 Iterator 7.5 Mediator 7.6 Memento 7.7 Null object 7.8 Observer 7.9 State 7.10 Strategy 7.11 Template method 7.12 Visitor "],
["cheatsheet.html", "8 Cheatsheet", " 8 Cheatsheet Add tables and images that show the difference between GRASP and SOLID, and different design patterns. "]
]
