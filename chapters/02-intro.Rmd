# Introduction

Many books explain software design with focus on one language (and paradigm) and assume that this
knowledge can be "easily" extrapolated to other languages and/or paradigms.
While it is true that you have to start from some point, it is also true that
as soon as you start to put it into practice in a different language,
their explanation may not be as easy to follow as you may have thought or may
not even make sense from the language perspective (see Fig. \@ref(fig:taming-code)
for an example of the author's feelings when reading such books).

```{r taming-code, echo=FALSE, results='asis', fig.cap='Developer taming code'}
knitr::include_graphics("../../img/Table-Languages.png")
```


<!-- ```{block2, type='note'} -->
<!-- For more information on custom blocks, remember to visit: -->
<!-- https://bookdown.org/yihui/bookdown/custom-blocks.html -->
<!-- ``` -->


## Software Design
<!-- Definition -->
Software design is the process of finding a *satisfactory* solution to a problem.
Before one can start with an implementation there needs to be a clear specification of the problem to solve,
maybe a domain model of the system under design (to get used to the domain jargon),
an (in)formal document that describes the steps necessary to solve the problem
(the Unified Modelling Language can help here with class and sequence diagrams, among others)
and a well-defined architecture.

<!-- Relation to agile methodogies -->
Given the definition above, designing software seems to be completely disjoint from
agile methodologies (e.g. Scrum) where you break user stories into smaller tasks
until everything is clear to the whole team. In Scrum there seems to be
no domain model, not a single static and/or behavioural diagram, no architecture, etc,
just *code what the post-it says*.
However, the post-it tells you **what the problem is** but not **how to solve it!**.
The domain modelling, static and behaviour models and architectural diagrams
are all tools under your belt that may be used if required, even in agile
methodologies.

<!-- Design is all about making decisions -->
Software design is all about making decisions.
Every problem involves taking small and big decisions and these influence the final
outcome of your software. For instance, the "simple" task of choosing a programming language
has a tremendous impact on your software. Choose a
dynamic language and you'll find quite a lot of errors at runtime (even if you use
a test-driven development approach). Other example is choosing between a
object-oriented or a functional language. No matter which one you choose, you can always write the same
piece of software using one paradigm or the other. However, one of them will
bring inherent benefits that have to be otherwise coded in the other approach.


### What is a good design?

<!-- good design == flexible design -->
In general, **a good design is one that can deal with change**.
<!-- software design is all about change -> comparison with other engineers -->
A software engineer has to think much more abstract than other engineers, e.g. civil engineer.
For instance, as a civil engineer, you may have to think about building a bridge that can stand
`X` number of tons and, under any circunstance, not fall down.
As a software engineer, you have to think about a piece of code that today is a car, tomorrow is a submarine
and the next day is a tank and this happens because it is just code, anyone can
update it and it is not set in stone, ever.

<!-- intro to design patterns -->
There are many ways to solve a problem and, more often than not, there are common solutions.
Because of this, many problems has been studied for many years and they have a well documented solution.
These well-documented solutions are called **design patterns** and they exist for
all kinds of paradigms. In this book, we will focus on object-oriented and
functional design patterns.

### Design patterns

<!-- definition, adv and disv -->
A design pattern is a well-desgined solution to a common problem.
Design patterns are expressed in a concise and clear format, and they
follow a structure similar to the one below:

- *pattern name*, so that experts can refer to a common pattern
- *concise and well-defined problem specification*
- *unequivocal solution*
- *trade-offs of the pattern*

In this book, we follow this structure together with auxiliary UML class
diagrams (explained in later chapters).

<!--
Should I cover design patterns from ASD? YES

Should I cover UML? ... maybe not!

Introduction to other languages!

Design patterns:
- SOLID vs GRASP
- Design patterns for OOP and/or FP
- Testing to check that it works!
-->
