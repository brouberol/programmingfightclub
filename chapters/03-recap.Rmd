# Recap

This section covers basic concepts from the object oriented and functional
paradigms. More conretely, by the end of the chapter you should be familiar with
the following concepts from object-oriented programming in Java and Python:

- Classes,
- objects,
- inheritance,
- interfaces,
- abstract classes and
- parametric classes

and the following concepts from functional programming in Clojure and Haskell:

- Anonymous functions / lambdas,
- high-order functions,
- parametric functions,
- algebraic data types,
- multi-functions
- immutability
- recursion

Keep in mind that some languages have features that do not exist in other languages.
For instance, algebraic data types exist in Haskell but not in Clojure and
parametric classes exist in Java but not in Python. In the former case,
algebraic data types cannot be fully build in Clojure due to its dynamic typing
nature -- Clojure cannot typecheck the difference between data types and data values
(we'll explain what this means later on). In the latter case, parametric functions
do not make sense for Python due to, again, its dynamic nature. If you got the
feeling that this does not make sense and you cannot follow, everything will be
explain with examples soon, when we cover these basic concepts.
Let's begin!

## Object-oriented concepts

The concepts covered in this section are shown in Java and Python.

*Note: Clojure is an impure language that mixes the functional programming
concepts with the object-oriented paradigm. In the remaning chapters,
we omit using the object-oriented capabilities of Clojure, since the objective
is to learn the main benefits that each language brings to the table.*

### Classes

Classes describe the state and behaviour of an object. The state of a class
lives in its attributes while the behaviour is expressed via its methods.
A class that hides its attributes with a `private` access modifier
(remember `public`, `protected` and `private`?) protects its internal state
from other classes. Now, the only way to update the internal state is
via method calls (**they represent the behaviour of the object**).
As a general advice, you should not expose the internal state of your class
to others; you should expose your behaviour. This is what make great abstractions
such as associative arrays, tasks and futures among others.

Classes expose their behaviour via its methods. If those methods just get
the attributes and set them, we call them *getters* and *setters*.

That's enough for
an introduction to something that should you already now, let's see some code!
Let's start with a typical example and work on it:

Idea:
Let's model a dog, who has as state her alertness and her behaviour is to bark
only when she is startled. As owner, you can check if the dog is startled or relaxed.

**Java**

The class `Dog` has as state a *private* attribute `alert`.
(the attribute is not accesible from outside the class).
The constructor of the class (`public Dog()`) creates a new `Dog` and sets its
state to some default value.
To get the state outside the class we use *getters* and *setters* methods.
These are preceded by the words `get` and `set` following the attributes name,
e.g. `getAlert`. This is represented in the Example 3.1.1.1.

```java
class Dog {
  // state of the Dog
  private boolean alert;

  // constructor
  public Dog(){
    this.alert = false;
  }

  // getter method
  public boolean getAlert(){
    return this.alert;
  }

  // setter method
  public void setAlert(boolean newAlert){
    this.alert = newAlert;
  }

  // behaviour
  public void bark(){
    if (this.alert) {
      System.out.println("Woof Woof");
    }
  }
}
```

*Example 3.1.1.1. Introductory example to Java*

**Python**

Python doesn't have access modifiers and uses (by convention) an underscore
(or two, let's now go into why) to mean that the attribute is private.
The constructor `def __init__(self, alert=False)` method takes explicitly
an instance of itself `self` and a default argument, `alert` that, if it's not
provided, it is set to `False`. Before we continue disecting the constructor,
let's briefly introduce getters and setters.

Python provides a special syntax for
getters and setters that wrap the attribute into a function with that very
same name. For instance, the getter for the `alert` attribute is created by
declaring a method with the name of the attribute and the `@property` on top of it.
The body of the method just fetches the attribute.

```python
    @property
    def alert(self):
      return self.__alert
```

Setters work in the same way, except that they
are annotated with the attribute's name followed by the `setter` word,
e.g. `@alert.setter` for the `alert` setter method.
From now on, when we call on `self.alert` we are actually calling the getter
method and when we assign `self.alert = True`, we are calling the setter method.


Now, if we go back to the `__init__` method from Example 3.1.1.2,
we can observe that this is indeed the desire behaviour.

**Why would we want to use getters and setters like that?**
Young padawan, they are an abstraction. Now you only want to retrieve the data but,
with this abstraction, you could be returning cached data that otherwise needs to be fetched
from the network. Later on, we will learn about the decorator pattern and how
it rocks in Python!

```{python PythonDog, echo=TRUE}
class Dog:
  def __init__(self, alert=False):
    self.alert = alert

  @property
  def alert(self):
    return self.__alert

  @alert.setter
  def alert(self, new_alert):
    self.__alert = new_alert

  def bark(self):
    if self.alert is True:
      print("Woof Woof")
```

*Example 3.1.1.2 Introductory example to Python*

### Objects

Objects represent instances of the [class](#classes) at runtime. An object gets the default
state defined by their constructor and the behaviour defined from the class declaration.

**Java**

Following the example before, let's create an object:
```java
Dog dog = new Dog();
```

This calls on the constructor of the `Dog` class that sets the `alert` state
to `false`. If the dog tries to bark nothing will happen:

```java
dog.bark();
```

The dog barks when it is startled, let's make her bark:

```java
dog.setAlert(true);
dog.bark();
// prints "Woof Woof"
```

**Python**

Creation of an object is similar to Java:

```{python, eval=FALSE, include=FALSE}
dog = Dog()
```

To make the dog bark:

```python
dog.bark()
```

which does nothing because the dog is not startled. Let's use the setter
to change its state and make her bark:

```python
dog.alert = True
dog.bark()
```

```{python, echo=FALSE}
class Dog:
  def __init__(self, alert=False):
    self.alert = alert

  @property
  def alert(self):
    return self.__alert

  @alert.setter
  def alert(self, new_alert):
    self.__alert = new_alert

  def bark(self):
    if self.alert is True:
      print("Woof Woof")

dog = Dog()      
dog.alert = True
dog.bark()
```

Notice that in this case, we could have set the initial state of the dog
and would not have had to use a setter:

```python
dog = Dog(True)
dog.bark()
```

```{python, echo=FALSE}
class Dog:
  def __init__(self, alert=False):
    self.alert = alert

  @property
  def alert(self):
    return self.__alert

  @alert.setter
  def alert(self, new_alert):
    self.__alert = new_alert

  def bark(self):
    if self.alert is True:
      print("Woof Woof")

dog = Dog()      
dog = Dog(True)
dog.bark()
```

### Inheritance

A class can inherit methods from other [classes], called inheritance. The class that
inherits methods is called *subclass* while the class that provides them is called
*super class*. Java has single inheritance, meaning that the subclass can inherit
only from a single class while Python has a limited form of multiple inheritance.

Idea: A computer has various levels of memory, L1, L2, Last-level cache and main
memory. In this example, the class `Computer` inherits operations from memory,
so that we can call methods that retrieve objects from main memory. (this is an
example and I would not advice any one to create a virtual machine based on
this idea)

**Java**

Since Java can only inherit from a single class, we can model the idea above as shown
in *Example 3.1.3 Java inheritance*.

```java
class Memory {

  private CacheL1 l1;
  private CacheL2 l2;

  public Memory(){
    int kilobyte = 1024*1024;
    int megabyte = 1024 * kilobyte;
    this.l1 = new CacheL1(512*kilobyte);
    this.l2 = new CacheL2(3*megabyte);
  }

  public Object fetchLocation(Location lo) { // ... }
}

class Computer extends Memory {
  public class Computer(){
    // ...
  }
}
```

*Example 3.1.3 Java inheritance*

The class `Computer` inherits the methods `Memory` when `Computer extends Memory`.
This means that we can fetch objects from memory, `computer.fetchLocation(location);`.


**Python**

Python supports two forms of multiple inheritance, known as old-style and
new style. In the old-style form, the multiple inheritance works in depth-first
and left-to-right order. For instance:

```python
class L1(object):
  def send_info():
    print "Sending from L1 to bus"

class L2(object):
  def send_info():
    print "Sending from L2 to bus"

class Cache(L1, L2):
  pass

class CPU(object):
  def send_info():
    print "Sending info from CPU to bus"

class Computer(CPU, Cache):
  pass

c = Computer()
c.send_info()
```

*Example 3.1.3 Python old-style*

In this case, the `c.send_info()` method prints `Sending info from CPU to bus`.
If we were to change the order of the inherited classes, `class Computer(Cache, CPU)`,
then the printing method would have been `Sending from L1 to bus`.

The multiple inheritance new style kicks in when classes do not inherit from `object`
(as opposed to what `L1` and `L2` do in *Example Python old-style*). The new style considers
breath-first and left-to-right order.

```python
class L1:
  def send_info():
    print "Sending from L1 to bus"

class L2:
  def send_info():
    print "Sending from L2 to bus"

class Cache(L1, L2):
  pass

class CPU:
  def send_info():
    print "Sending info from CPU to bus"

class Computer(Cache, CPU):
  pass

c = Computer()
c.send_info()
```

*Example 3.1.3 Python new style*

In *Example 3.1.3 Python new style*, the `c.send_info()` method would have printed
`Sending info from CPU to bus` given that `Cache` does not provide a suitable
`send_info` method explictly.

(More details in here: http://www.python-course.eu/python3_multiple_inheritance.php)

### Interfaces

**TODO: missing default methods and static methods in interfaces (they can have implementations!)**

Interfaces declare a contract of the expected behaviour of classes that implement
the interface. An interface *merely* defines methods. Classes that would like
to be compatible with the interface need to implement those methods. The real
purpose of interfaces is to enable polymorphism, e.g. being able to call methods
on different classes because they implement the same interface. Java has interfaces but Python completely
lacks them. Dynamic languages such as Python cannot express interfaces because
they don't have a static type system, the fact of not having static types inhibits
interfaces.

**Java**

In Java an interface is declared similar to how classes are declared, except that
you use the word `interface`.

```java
interface MemOperations {
  public Object fetchLocation(Location loc);
  public void flush();
  public void sendToBus();
}

public class CacheL1 implements MemOperations {
  public CacheL1(int size){
    //...
  }

  public Object fetchLocation(Location loc){
    // ...
  }

  // ...

  public void flush(){
    System.out.println("Flushing from CacheL1");
  }

}

public class CacheL2 implements MemOperations {
  // ...

  public void flush(){
    System.out.println("Flushing from CacheL2");
  }
}

```

*Example 3.1.4 Java interfaces*

If you forget to implement one of the methods declared in the interface,
the type system will throw an error and complain that you forgot to
implement the missing methods. You won't get unexpected crashes at runtime because
the method doesn't exist.

From the *Example 3.1.4 Java Interfaces* we can create different cache levels
and treat them as if they are just `MemOperations`. Calling methods on each
one prints a different `String`.

```
CacheL1 c1 = new CacheL1(512);
CacheL2 c2 = new CacheL2(2048);

ArrayList<MemOperations> a = new ArrayList<MemOperations>();
a.append(c1);
a.append(c2);

for(cache: a){
  cache.flush();
}

// prints:
// "Flushing from CacheL1"
// "Flushing from CacheL2"
```

As of Java 8, interfaces can declare a *default* implementation for methods.
This is great from the design point of view: you can provide a default implementation
as long as you rely only on the known behaviour (other public methods of the interface).
This means that you can create a clean design that does not rely on internal state
and/or methods.

**TODO: Template pattern fits here perfectly!**

**TODO: Should I explain polymorphism here? It's GRASP...**

**TODO: Should I show a code example?**

**TODO: I believe I am explaining super basic stuff and should level up...**


### Abstract classes

Abstract classes can be seen as a mix between [interfaces] and [classes]:
they can contain attributes, define methods and declare abstract methods.
Abstract methods provide a declaration of the behaviour but not a definition (implementation).
An abstract class cannot work on its own -- cannot be instantiated alone --
and needs to be subclass by another class, which implements the abstract methods.

**Java**

It may seem as if [Interfaces] (as of Java 8) and [Abstract Classes] serve the same purpose.
However, there is a subtle difference: an interface can only create public methods and
constant declarations (*static* and *final* attributes) while an abstract class
can declare and define the internal state of the class.

As an advice, I would recommend to use interfaces whenever you have various subclasses
that need to implement the same behaviour. I would consider the use of an
abstract class in limited cases and only when there is a need to share the same private
state among objects that are quite similar.

**TODO: Favour composition over inheritance**


```java
abstract class Entity {
  private int life;
  private Equipment equipment;

  public Entity(int life, Equipment Equipment){
    this.life = life;
    this.equipment = equipment;
  }

  public int getLife() { return this.life; }
  public void setLife(int life) { this.life = life; }

  abstract void attack(Enemy e);
  abstract void escape();
  // ...
}

interface Attackable {
  public int getPower();

  default void attack(Enemy e){
    e.setLife(e.getLife() - getPower());
  }
}

public class Hero {
  public void attack(Enemy e){
    // Filter equipment by things that I can attack with
    Attackable attackable = this.equipment.attackable();

    // attack
    attackable.attack(e);
  }
}
```

**TODO: equipment may use the null pattern**

**Python**

Test [^metadata]

[^metadata]: Python allows creation of abstract classes via meta classes. These
concept is a bit more advanced and may be covered upon receiving some initial feedback.

### Parametric classes


## Functional concepts

### Anonymous functions / lambdas

### Immutability

### High-order functions

### Parametric functions

### Algebraic data types

### Multi-functions
